//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirst_symbTabGen<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
  SymbolTable2 tab;
  int curStmtCnt;
  Hashtable<String,Integer> labelStmtNo;
  String curProcedure;
  LinearScan curLinScan;
  Integer registerCount;
  TreeSet<Integer> stmtUsedHolder;
  TreeSet<Integer> stmtDefdHolder;
  Stack<Integer> collectArgs;
  TreeMap<Integer,String> stmtToLabelEdgs;
   public GJDepthFirst_symbTabGen(SymbolTable2 tb,Integer regCnt)
   {
    super();
    tab = tb;
    curStmtCnt = 1;
    curProcedure = null;
    registerCount = regCnt;
    collectArgs = new Stack<Integer>();
    stmtToLabelEdgs = new TreeMap<Integer,String>();
   }

   class Interval
   {
    public int left;
    public int right;
    public int varId;
    public void print()
    {
      System.out.println("{" + varId + " = (" + left + "," + right + ") }");
    }
   }
   class LinearScan
   {
    Vector< Vector<Integer> > adjList;
    Vector<TreeSet<Integer>> used;
    Vector<TreeSet<Integer>> defd;
    TreeMap<Integer,Interval> intervals;
    int registerCount;
    public LinearScan(int regCnt)
    {
      adjList = new Vector<Vector<Integer>> ();
      used = new Vector<TreeSet<Integer>>();
      defd = new Vector<TreeSet<Integer>>();
      //add EntryNode
      Vector<Integer> nw = new Vector<Integer>();
      adjList.addElement(nw);
      TreeSet<Integer> u = new TreeSet<Integer> ();
      TreeSet<Integer> v = new TreeSet<Integer>();
      used.addElement(u);
      defd.addElement(v);
      registerCount = regCnt;
    }
    public void addV(TreeSet<Integer> u,TreeSet<Integer> d)
    {
      Vector<Integer> nw = new Vector<Integer>();
      adjList.addElement(nw);
      used.addElement(u);
      defd.addElement(d);
    }
    public void addE(int a,int b)
    {
      adjList.get(a).addElement(b);
    }
    public void makeIntervals()
    {
      intervals = new TreeMap<Integer,Interval>();
      int n = adjList.size();
      if(n < 2)
      {
        System.out.println("ERROR:NO EXIT NODE");
        System.exit(0);
      }
      Vector<TreeSet<Integer>> in = new Vector<TreeSet<Integer>>();
      Vector<TreeSet<Integer>> out = new Vector<TreeSet<Integer>>();
      for(int i = 0;i < n;i++) 
      {
        in.addElement(new TreeSet<Integer>());
        out.addElement(new TreeSet<Integer>());
      }
      Boolean hasChanged = true;
      while(hasChanged)
      {
        hasChanged = false;
        for(int i = n-2;i >= 0;i--)
        {
          TreeSet<Integer> nwOut = out.get(i);
          nwOut.clear();
          for(int j:adjList.get(i))
          {
            nwOut.addAll(in.get(j));
          }
          TreeSet<Integer> curIn = new TreeSet<Integer>();
          curIn.addAll(used.get(i));
          TreeSet<Integer> def = defd.get(i);
          for(int x:nwOut)
          {
            if(!def.contains(x))
            {
              curIn.add(x);
            }
          }
          TreeSet<Integer> oldIn = in.get(i);
          if(!curIn.equals(oldIn))
          {
            hasChanged = true;
            in.set(i,curIn);
          }
        }
      }
      for(int i = 0;i < n;i++)
      {
        TreeSet<Integer> allLive = new TreeSet<Integer>();
        allLive.addAll(in.get(i));
        allLive.addAll(defd.get(i));
        for(int x:allLive)
        {
           Interval iv = intervals.get(x);
           if(iv == null)
           {
            iv = new Interval();
            iv.left = i;
            iv.right = i;
            iv.varId = x;
            intervals.put(x,iv);
           }
           else
           {
            iv.left = Math.min(iv.left,i);
            iv.right = Math.max(iv.right,i);
           }
        }
      }
    }
    public TreeMap<Integer,Integer> getAllocation()
    {
      makeIntervals();
      TreeMap<Integer,Integer> resAlloc = new TreeMap<Integer,Integer>();
      Vector<Interval> tmpIntv = new Vector<Interval>();
      Set<Integer> st = intervals.keySet();
      //System.out.println("Intervals:" );
      for(int m:st)
      {
        Interval e = intervals.get(m);
        tmpIntv.addElement(e);
        //e.print();
      }
      class MyCompar implements Comparator<Interval>
      {
        public int compare(Interval a,Interval b)
        {
          if(a.left < b.left) return -1;
          if(a.left > b.left) return 1;
          if(a.right < b.right) return -1;
          if(a.right > b.right) return 1;
          return 0;
        }
      }
      MyCompar compar = new MyCompar();
      class MyCompar2 implements Comparator<Interval>
      {
        public int compare(Interval a,Interval b)
        {
          if(a.right < b.right) return -1;
          if(a.right > b.right) return 1;
          if(a.varId < b.varId) return -1;
          if(a.varId > b.varId) return 1;
          return 0;
        }
      }
      Collections.sort(tmpIntv,compar);
      TreeSet<Interval> activeSet = new TreeSet<Interval>(new MyCompar2());
      int sz = tmpIntv.size();
      Vector<Integer> freeRegisters = new Vector<Integer>();
      for(int i = 0;i < registerCount;i++)
      {
        freeRegisters.addElement(i);
      }
      class SpillCnt
      {
        public Integer spillCounter;
        public SpillCnt()
        {
          spillCounter = registerCount;
        }
      }
      SpillCnt spillCounter = new SpillCnt();
      class TempMethods
      {
        public void expireOldIntervals(int i)
        {
          Interval a = tmpIntv.get(i);
          while(true)
          {
            if(activeSet.isEmpty()) break;
            Interval c = activeSet.first();
            if(c.right >= a.left) return;
            activeSet.remove(c);
            freeRegisters.addElement(resAlloc.get(c.varId));
          }
        }
        public void spillAtInterval(int i)
        {
          Interval c  = activeSet.last();
          Interval a = tmpIntv.get(i);
          if(c.right > a.right)
          {
            int r = resAlloc.get(c.varId);
            resAlloc.put(a.varId,r);
            resAlloc.put(c.varId,spillCounter.spillCounter);
            spillCounter.spillCounter++;
            activeSet.remove(c);
            activeSet.add(a);
          }
          else
          {
            resAlloc.put(a.varId,spillCounter.spillCounter);
            spillCounter.spillCounter++;
          }
        }
      }
      TempMethods tmp = new TempMethods();
      for(int i = 0;i < sz;i++)
      {
        //tmpIntv.get(i).print();
        tmp.expireOldIntervals(i);
        //System.out.println("size: " + activeSet.size());
        if(activeSet.size()==registerCount)
        {
          tmp.spillAtInterval(i);
        }
        else
        {
          int r = freeRegisters.lastElement();
          //System.out.println("Allocated Register: "+ r);
          freeRegisters.remove(freeRegisters.size()-1);
          Interval a = tmpIntv.get(i);
          resAlloc.put(a.varId,r);
          activeSet.add(a);
        }
      }
      return resAlloc;
    }
   }
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return (R)n.tokenImage; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      curProcedure = "MAIN";
      curLinScan = new LinearScan(registerCount);
      n.f1.accept(this, argu);
      Set<Integer> k = stmtToLabelEdgs.keySet();
      for(int x:k)
      {
        String l = stmtToLabelEdgs.get(x);
        Integer y = labelStmtNo.get(l);
        curLinScan.addE(x,y);
      }
      tab.putMap(curProcedure,curLinScan.getAllocation());
      n.f2.accept(this, argu);
      curProcedure = null;
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      labelStmtNo = new Hashtable<String,Integer>();
      stmtToLabelEdgs.clear();
      curStmtCnt = 1;
      String temp = "fromStmtList";
      n.f0.accept(this, (A)temp);
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      R _ret=null;
      String proc = (String) n.f0.accept(this, argu);
      curProcedure = proc;
      curLinScan = new LinearScan(registerCount);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      Set<Integer> k = stmtToLabelEdgs.keySet();
      for(int x:k)
      {
        String l = stmtToLabelEdgs.get(x);
        Integer y = labelStmtNo.get(l);
        curLinScan.addE(x,y);
      }
      tab.putMap(curProcedure,curLinScan.getAllocation());
      curProcedure = null;
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
      R _ret=null;
      String arg = (String) argu;
      if(arg.equals("fromStmtList"))
      {
        String temp = "fromStmtScan";
        stmtUsedHolder = new TreeSet<Integer>();
        stmtDefdHolder = new TreeSet<Integer>();
        n.f0.accept(this, (A)temp);
        curLinScan.addV(stmtUsedHolder,stmtDefdHolder);
        stmtUsedHolder = null;
        stmtDefdHolder = null;
        curLinScan.addE(curStmtCnt-1,curStmtCnt);        
      }
      n.f0.accept(this,argu);
      if(arg.equals("fromStmtList"))
      {
        curStmtCnt++;
      }
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
      String arg = (String) argu;
      if(arg.equals("fromStmtScan"))
      {
        argu = null;
      }
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;
      String arg = (String) argu;
      if(arg.equals("fromStmtScan"))
      {
        argu = null;
      }      
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, (A) null);
      String num = (String) n.f1.accept(this, (A) null);
      String lab = (String) n.f2.accept(this, (A) null);
      String arg = (String) argu;
      if(arg.equals("fromStmtScan"))
      {
        stmtUsedHolder.add(Integer.valueOf(num));
        stmtToLabelEdgs.put(curStmtCnt,lab);
      }
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String lab = (String) n.f1.accept(this, argu);
      String arg = (String) argu;
      if(arg.equals("fromStmtScan"))
      {
        stmtToLabelEdgs.put(curStmtCnt,lab);
      }
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, (A) null);
      String num1 = (String) n.f1.accept(this, (A) null);
      n.f2.accept(this, (A) null);
      String num2 = (String) n.f3.accept(this, (A) null);
      String arg = (String) argu;
      if(arg.equals("fromStmtScan"))
      {
        stmtUsedHolder.add(Integer.valueOf(num1));
        stmtUsedHolder.add(Integer.valueOf(num2));
      }
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, (A) null);
      String num1 = (String) n.f1.accept(this, (A) null);
      String num2 = (String) n.f2.accept(this, (A) null);
      n.f3.accept(this, (A) null);
      String arg = (String) argu;
      if(arg.equals("fromStmtScan"))
      {
        stmtUsedHolder.add(Integer.valueOf(num2));
        stmtDefdHolder.add(Integer.valueOf(num1));
      }
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret=null;
      String arg = (String) argu;
      argu = null;
      n.f0.accept(this, argu);
      String num = (String) n.f1.accept(this, argu);
      if(arg.equals("fromStmtScan"))
      {
        stmtDefdHolder.add(Integer.valueOf(num));
      }
      n.f2.accept(this, (A) arg);
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, (A) null);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      String fromReturn = "fromReturn";
      n.f3.accept(this, (A) fromReturn);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      String fromCall = "fromCall";
      collectArgs.clear();
      n.f3.accept(this, (A) fromCall);
      stmtUsedHolder.addAll(collectArgs);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String num = (String) n.f1.accept(this, argu);
      String arg = (String) argu;
      if(arg.equals("fromStmtScan"))
      {
        stmtUsedHolder.add(Integer.valueOf(num));
      }
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      R _ret=null;
      String arg = (String) argu;
      String t = (String)  n.f0.accept(this, (A)null);
      if(arg.equals("fromStmtScan") || arg.equals("fromReturn"))
      {
        if(n.f0.which==0)
        {
          stmtUsedHolder.add(Integer.valueOf(t));
        }
      }
      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String arg = (String) argu;
      String num = (String) n.f1.accept(this, argu);
      if(arg.equals("fromCall"))
      {
        collectArgs.push(Integer.valueOf(num));
      }
      return (R) num;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      String num = (String) n.f0.accept(this, argu);
      return (R) num;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret=null;
      String label = (String) n.f0.accept(this, (A)null);
      String arg = (String) argu;
      if(arg.equals("fromStmtList"))
      {
        labelStmtNo.put(label,curStmtCnt);
      }
      return (R) label;
   }

}
